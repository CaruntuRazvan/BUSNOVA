8. Crearea un tabel de mesaje:
CREATE TABLE Mesaj (
    cod_mesaj NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    mesaj VARCHAR2(255),
    tip_mesaj VARCHAR2(1),
    creat_de VARCHAR2(40) NOT NULL,
    creat_la DATE DEFAULT SYSDATE NOT NULL,
    
    -- Constrângere pentru validarea tipului de mesaj (CHECK)
    CONSTRAINT ck_tip_mesaj CHECK (tip_mesaj IN ('E', 'W', 'I'))
);


9.
• subprogram stocat independent (inclusiv apelare) care să utilizeze toate cele 3 tipuri de colecții învăţate;

-- Să se implementeze un sistem de loialitate pentru calcularea recompenselor de tip Cashback pentru clienți.

CREATE OR REPLACE TYPE tip_praguri AS VARRAY(4) OF NUMBER;
/

CREATE OR REPLACE PROCEDURE proc_sistem_loialitate AS
    
    TYPE rec_info_client IS RECORD (
        nume  Client.nume_complet%TYPE,
        email Client.email%TYPE,
        suma_cashback NUMBER
    );

    v_praguri tip_praguri := tip_praguri(5, 10, 15, 20);
    
    TYPE tip_lista_id IS TABLE OF NUMBER;
    v_ids tip_lista_id;
    
    TYPE tip_map_detaliat IS TABLE OF rec_info_client INDEX BY PLS_INTEGER;
    v_raport_final tip_map_detaliat;
    
    v_total_cheltuit NUMBER;
    v_idx PLS_INTEGER;
    v_info_baza Client%ROWTYPE;
BEGIN
    
    SELECT DISTINCT client_id 
    BULK COLLECT INTO v_ids 
    FROM Rezervare;

    DBMS_OUTPUT.PUT_LINE('         RAPORT LOIALITATE       ');
    DBMS_OUTPUT.PUT_LINE('-------------------------------------------');

    -- B. Procesam fiecare client
    FOR i IN 1..v_ids.COUNT LOOP
        
        SELECT * INTO v_info_baza FROM Client WHERE client_id = v_ids(i);
        
        --pret din rezervare
        SELECT SUM(pret) INTO v_total_cheltuit FROM Rezervare WHERE client_id = v_ids(i);
        
        v_raport_final(v_ids(i)).nume := v_info_baza.nume_complet;
        v_raport_final(v_ids(i)).email := v_info_baza.email;
        
        IF v_total_cheltuit > 500 THEN
            v_raport_final(v_ids(i)).suma_cashback := v_total_cheltuit * (v_praguri(4)/100);
        ELSIF v_total_cheltuit > 300 THEN
            v_raport_final(v_ids(i)).suma_cashback := v_total_cheltuit * (v_praguri(3)/100);
        ELSIF v_total_cheltuit > 100 THEN
            v_raport_final(v_ids(i)).suma_cashback := v_total_cheltuit * (v_praguri(2)/100);
        ELSE
            v_raport_final(v_ids(i)).suma_cashback := v_total_cheltuit * (v_praguri(1)/100);
        END IF;
    END LOOP;
    -- afisare rezultate
    v_idx := v_raport_final.FIRST;
    WHILE v_idx IS NOT NULL LOOP
        DBMS_OUTPUT.PUT_LINE('ID: ' || RPAD(v_idx, 3) || 
                             ' | Nume: ' || RPAD(v_raport_final(v_idx).nume, 18) || 
                             ' | Email: ' || RPAD(v_raport_final(v_idx).email, 18) || 
                             ' | Cashback: ' || v_raport_final(v_idx).suma_cashback || ' RON');
        v_idx := v_raport_final.NEXT(v_idx);
    END LOOP;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Eroare: Datele clientului nu au fost gasite.');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Eroare neasteptata: ' || SQLERRM);
END;
/

-- rulare
EXEC proc_sistem_loialitate;


• subprogram stocat independent (inclusiv apelare) care să utilizeze 2 tipuri de cursoare învățate, unul dintre acestea fiind cursor parametrizat, dependent de celălalt cursor;

-- Să se proiecteze o procedură PROC_RAPORT_EFICIENTA_CURSE care să analizeze performanța financiară și gradul de ocupare al curselor dintr-o perioadă specificată (lună și an).

CREATE OR REPLACE PROCEDURE PROC_RAPORT_EFICIENTA_CURSE (
    p_luna NUMBER, 
    p_an NUMBER
) AS
    -- Cursor explicit parametrizat corectat (folosim nume_complet)
    CURSOR c_detalii_pasageri(p_id_cursa NUMBER) IS
        SELECT c.nume_complet, r.pret, r.nr_loc
        FROM Client c
        JOIN Rezervare r ON c.client_id = r.client_id
        WHERE r.cursa_id = p_id_cursa
        ORDER BY r.nr_loc ASC;

    v_total_incasat     NUMBER(10, 2);
    v_nr_pasageri       NUMBER;
    v_grad_ocupare      NUMBER(5, 2);
BEGIN
    DBMS_OUTPUT.PUT_LINE('=== RAPORT EFICIENTA CURSE PE PERIOADA: ' || p_luna || '/' || p_an || ' ===');

    -- Cursor Implicit
    FOR r_cursa IN (
        SELECT c.cursa_id, c.data_ora_plecare, ru.nume_ruta, a.total_locuri, a.nr_inmatriculare
        FROM Cursa c
        JOIN Ruta ru ON c.ruta_id = ru.ruta_id
        JOIN Autobuz a ON c.autobuz_id = a.autobuz_id
        WHERE EXTRACT(MONTH FROM c.data_ora_plecare) = p_luna
          AND EXTRACT(YEAR FROM c.data_ora_plecare) = p_an
    ) LOOP
        v_total_incasat := 0;
        v_nr_pasageri := 0;

        DBMS_OUTPUT.PUT_LINE(CHR(10) || 'CURSA #' || r_cursa.cursa_id || ' | RUTA: ' || r_cursa.nume_ruta);
        DBMS_OUTPUT.PUT_LINE('Autobuz: ' || r_cursa.nr_inmatriculare || ' | Data: ' || TO_CHAR(r_cursa.data_ora_plecare, 'DD.MM HH24:MI'));
        DBMS_OUTPUT.PUT_LINE('------------------------------------------------------------');

        FOR r_p IN c_detalii_pasageri(r_cursa.cursa_id) LOOP
            v_nr_pasageri   := v_nr_pasageri + 1;
            v_total_incasat := v_total_incasat + r_p.pret;
            
            -- Am schimbat r_p.nume si r_p.prenume cu r_p.nume_complet
            DBMS_OUTPUT.PUT_LINE('   Loc ' || r_p.nr_loc || ': ' || r_p.nume_complet || ' (' || r_p.pret || ' RON)');
        END LOOP;

        IF v_nr_pasageri > 0 THEN
            v_grad_ocupare := (v_nr_pasageri / r_cursa.total_locuri) * 100;
            DBMS_OUTPUT.PUT_LINE('>> STATISTICI: ' || v_nr_pasageri || ' pasageri | Ocupare: ' || v_grad_ocupare || '%');
            DBMS_OUTPUT.PUT_LINE('>> INCASARI TOTALE: ' || v_total_incasat || ' RON');
            
            IF v_grad_ocupare < 30 THEN
                DBMS_OUTPUT.PUT_LINE('!! ATENTIE: Cursa neprofitabila (sub 30% ocupare)');
            END IF;
        ELSE
            DBMS_OUTPUT.PUT_LINE('   (Cursa nu are rezervari confirmate)');
        END IF;
    END LOOP;
END;
/

--rulare
EXEC PROC_RAPORT_EFICIENTA_CURSE(1, 2026);


• subprogram stocat independent de tip funcție care să utilizeze într-o singură comandă SQL 3 dintre tabelele definite; tratarea tuturor excepțiilor care pot apărea (definiți minim 2 excepții proprii, altele decât cele predefinite la nivel de sistem); apelarea subprogramului astfel încât să fie evidențiate toate cazurile definite și tratate;

-- Să se implementeze o funcție ce determină prețul unui bilet interogând tabelele Cursa, Pret_Segment și Statie.

CREATE OR REPLACE FUNCTION calculeaza_pret_calatorie(
    p_cursa_id NUMBER,
    p_statie_plecare_id NUMBER,
    p_statie_sosire_id NUMBER
) RETURN NUMBER AS
    PRAGMA AUTONOMOUS_TRANSACTION; 
    
    ex_cursa_invalida EXCEPTION;
    ex_segment_inexistent EXCEPTION;
    
    v_pret NUMBER := 0;
    v_statie_plecare VARCHAR2(100);
    v_statie_sosire VARCHAR2(100);
    v_cursa_exista NUMBER := 0;
    v_mesaj_text VARCHAR2(255);  
    
BEGIN

    SELECT COUNT(*) INTO v_cursa_exista FROM Cursa WHERE cursa_id = p_cursa_id;
    IF v_cursa_exista = 0 THEN
        RAISE ex_cursa_invalida;
    END IF;
    
    BEGIN
        SELECT ps.pret_baza, s1.oras, s2.oras
        INTO v_pret, v_statie_plecare, v_statie_sosire
        FROM Cursa c
        INNER JOIN Pret_Segment ps ON c.ruta_id = ps.ruta_id
        INNER JOIN Statie s1 ON ps.statie_plecare_id = s1.statie_id
        INNER JOIN Statie s2 ON ps.statie_sosire_id = s2.statie_id
        WHERE c.cursa_id = p_cursa_id
          AND ps.statie_plecare_id = p_statie_plecare_id
          AND ps.statie_sosire_id = p_statie_sosire_id;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE ex_segment_inexistent;
    END;
    
    v_mesaj_text := 'Pret calculat: ' || v_statie_plecare || ' -> ' || 
                    v_statie_sosire || ' = ' || v_pret || ' RON';
    
    INSERT INTO Mesaj (mesaj, tip_mesaj, creat_de)
    VALUES (v_mesaj_text, 'I', 'FUNC_PRET');
    
    COMMIT; 
    RETURN v_pret;
    
EXCEPTION
    WHEN ex_cursa_invalida THEN
        v_mesaj_text := 'EROARE: Cursa #' || p_cursa_id || ' nu exista!';
        INSERT INTO Mesaj (mesaj, tip_mesaj, creat_de)
        VALUES (v_mesaj_text, 'E', 'FUNC_PRET');
        COMMIT;
        RETURN -1;
        
    WHEN ex_segment_inexistent THEN
        v_mesaj_text := 'EROARE: Segment inexistent pentru cursa #' || p_cursa_id;
        INSERT INTO Mesaj (mesaj, tip_mesaj, creat_de)
        VALUES (v_mesaj_text, 'E', 'FUNC_PRET');
        COMMIT;
        RETURN -2;
        
    WHEN OTHERS THEN
        v_mesaj_text := 'EROARE SISTEM: ' || SQLERRM;
        INSERT INTO Mesaj (mesaj, tip_mesaj, creat_de)
        VALUES (SUBSTR(v_mesaj_text, 1, 255), 'E', 'FUNC_PRET');
        COMMIT;
        RETURN -99;
END calculeaza_pret_calatorie;
/

--testare cazuri
SET SERVEROUTPUT ON;

DECLARE
    v_rezultat NUMBER;
BEGIN
    --succes
    v_rezultat := calculeaza_pret_calatorie(1, 1, 2);
    DBMS_OUTPUT.PUT_LINE(v_rezultat);

    -- nu exista id cursa
    v_rezultat := calculeaza_pret_calatorie(9999, 1, 2);
    DBMS_OUTPUT.PUT_LINE(v_rezultat);

    -- segment nedefinit in tabela PRET_SEGMENT
    v_rezultat := calculeaza_pret_calatorie(1, 1, 999);
    DBMS_OUTPUT.PUT_LINE(v_rezultat);
END;
/


• Trigger de tip LMD la nivel de comandă (inclusiv declanșare);

-- Să se implementeze un trigger la nivel de comandă care, la fiecare inserare sau modificare de curse, verifică automat starea de mentenanță a întregii flote de autobuze. Trigger-ul trebuie să identifice autobuzele active care nu au avut mentenanță în ultimele 3 luni (90 zile) și să genereze mesaje de alertă: avertismente (WARNING) pentru autobuze cu 90-180 zile fără mentenanță și alerte critice (ERROR) pentru cele cu peste 180 zile. Pentru a evita spam-ul, trigger-ul nu creează mesaje duplicate pentru același autobuz în aceeași zi.

CREATE OR REPLACE TRIGGER trg_verificare_flota_la_cursa
AFTER INSERT OR UPDATE ON Cursa
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION;
    
    TYPE t_autobuz_info IS RECORD (
        autobuz_id           NUMBER,
        nr_inmatriculare     VARCHAR2(20),
        marca_model          VARCHAR2(100),
        zile_fara_mentenanta NUMBER
    );
    TYPE t_autobuze IS TABLE OF t_autobuz_info;
    v_lista_risc t_autobuze;
    
    v_pragul_zile   NUMBER := 90;
    v_pragul_critic NUMBER := 180;
    v_mesaj_existent NUMBER;
    v_alerte_create  NUMBER := 0;
    v_text_final  VARCHAR2(255); 
    v_tip_final   VARCHAR2(1);
BEGIN
    -- Selectam autobuzele
    SELECT 
        a.autobuz_id,
        a.nr_inmatriculare,
        a.marca || ' ' || a.model,
        TRUNC(SYSDATE - NVL(MAX(m.data_sfarsit), TO_DATE(a.an_fabricatie || '-01-01', 'YYYY-MM-DD')))
    BULK COLLECT INTO v_lista_risc
    FROM Autobuz a
    LEFT JOIN Mentenanta m ON a.autobuz_id = m.autobuz_id
    WHERE a.status = 'activ'
    GROUP BY a.autobuz_id, a.nr_inmatriculare, a.marca, a.model, a.an_fabricatie
    HAVING TRUNC(SYSDATE - NVL(MAX(m.data_sfarsit), TO_DATE(a.an_fabricatie || '-01-01', 'YYYY-MM-DD'))) >= v_pragul_zile;
    
    FOR i IN 1 .. v_lista_risc.COUNT LOOP
        SELECT COUNT(*)
        INTO v_mesaj_existent
        FROM Mesaj
        WHERE creat_de = 'SISTEM_FLOTA'
          AND TRUNC(creat_la) = TRUNC(SYSDATE)
          AND mesaj LIKE '%' || v_lista_risc(i).nr_inmatriculare || '%';
        
        IF v_mesaj_existent = 0 THEN
            -- Construim mesajul complet
            IF v_lista_risc(i).zile_fara_mentenanta >= v_pragul_critic THEN
                v_tip_final := 'E';
                v_text_final := 'CRITIC: Autobuz ' || v_lista_risc(i).nr_inmatriculare || 
                                ' (' || v_lista_risc(i).marca_model || ') fara mentenanta de ' || 
                                v_lista_risc(i).zile_fara_mentenanta || ' zile!';
            ELSE
                v_tip_final := 'W';
                v_text_final := 'ATENTIE: Autobuz ' || v_lista_risc(i).nr_inmatriculare || 
                                ' (' || v_lista_risc(i).marca_model || ') fara mentenanta de ' || 
                                v_lista_risc(i).zile_fara_mentenanta || ' zile!';
            END IF;
            
            -- trunchiaza la 255 caractere
            v_text_final := SUBSTR(v_text_final, 1, 255);
            
            -- INSERT cu variabilele deja construite
            INSERT INTO Mesaj (mesaj, tip_mesaj, creat_de)
            VALUES (v_text_final, v_tip_final, 'SISTEM_FLOTA');
            
            v_alerte_create := v_alerte_create + 1;
        END IF;
    END LOOP;
    
    IF v_alerte_create > 0 THEN
        v_text_final := 'Verificare flota: ' || v_alerte_create || 
                        ' alerte noi create (' || v_lista_risc.COUNT || ' verificate)';
        v_text_final := SUBSTR(v_text_final, 1, 255);
        
        INSERT INTO Mesaj (mesaj, tip_mesaj, creat_de)
        VALUES (v_text_final, 'I', 'SISTEM_FLOTA');
    END IF;
    
    COMMIT;
    
EXCEPTION
    WHEN OTHERS THEN
        v_text_final := 'Eroare verificare flota: ' || SQLERRM;
        v_text_final := SUBSTR(v_text_final, 1, 255);
        
        INSERT INTO Mesaj (mesaj, tip_mesaj, creat_de)
        VALUES (v_text_final, 'E', 'SISTEM_FLOTA');
        COMMIT;
END;
/

-- insert pentru a declansa trigger-ul
INSERT INTO Cursa (ruta_id, autobuz_id, sofer_id, data_ora_plecare, status)
VALUES (1, 1, 1, SYSTIMESTAMP + INTERVAL '2' DAY, 'planificata');
-- mesaje generate
SELECT * FROM Mesaj
WHERE creat_de = 'SISTEM_FLOTA' 
ORDER BY creat_la DESC;
 


•Trigger de tip LMD la nivel de linie (inclusiv declanșare);

-Să se creeze un trigger care, înainte de a introduce o nouă rezervare, verifică dacă locul respectiv este liber pe segmentul de drum solicitat. Dacă locul este deja ocupat între stația de plecare și cea de sosire a noii cereri, se va arunca o eroare. Dacă locul se eliberează (pasagerul anterior coboară), rezervarea este permisă.

CREATE OR REPLACE TRIGGER trg_verificare_segment_loc
BEFORE INSERT ON Rezervare
FOR EACH ROW
DECLARE
    v_ocupat NUMBER;
BEGIN

    SELECT COUNT(*) INTO v_ocupat
    FROM Rezervare
    WHERE cursa_id = :NEW.cursa_id
      AND nr_loc = :NEW.nr_loc
      AND (
        (:NEW.statie_plecare_id < statie_sosire_id AND :NEW.statie_sosire_id > statie_plecare_id)
      );

    IF v_ocupat > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Locul ' || :NEW.nr_loc || ' este deja ocupat pe o portiune din acest traseu!');
    END IF;
END;
/
-- Declanșare:
-- Aceasta va da EROARE (locul 5 e deja ocupat)
INSERT INTO Rezervare (client_id, cursa_id, nr_loc, statie_plecare_id, statie_sosire_id, pret) 
VALUES (1, 1, 5, 1, 3, 40); 

• Trigger de tip LDD (inclusiv declanșare);
-Să se implementeze un trigger care să salveze într-un tabel Audit_Schema orice modificare adusă tabelelor bazei de date (creări, ștergeri sau modificări). Sistemul trebuie să salveze cine a făcut modificarea, ce obiect a fost afectat și în ce zi.
-- audit
CREATE TABLE Audit_Schema (
    audit_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    tip_operatie VARCHAR2(20),
    obiect_tip VARCHAR2(30),
    obiect_nume VARCHAR2(100),
    comanda_sql CLOB,
    utilizator VARCHAR2(50),
    data_operatie TIMESTAMP DEFAULT SYSTIMESTAMP,
    ip_sursa VARCHAR2(50)
);
-- Trigger LDD
CREATE OR REPLACE TRIGGER trg_audit_schema
AFTER CREATE OR ALTER OR DROP ON SCHEMA
BEGIN
    INSERT INTO Audit_Schema (
        tip_operatie,
        obiect_tip,
        obiect_nume,
        comanda_sql,
        utilizator,
        ip_sursa
    ) VALUES (
        SYS.DICTIONARY_OBJ_TYPE,
        SYS.DICTIONARY_OBJ_NAME,
        SYS.SYSEVENT,
        SYS.LOGIN_USER || ' - ' || SYS.SYSEVENT,
        SYS.LOGIN_USER,
        SYS_CONTEXT('USERENV', 'IP_ADDRESS')
    );
END;
/

--testare
CREATE TABLE TEST_AUDIT (id NUMBER); 
ALTER TABLE TEST_AUDIT ADD nume VARCHAR2(50);
DROP TABLE TEST_AUDIT; 

SELECT * FROM Audit_Schema ORDER BY data_operatie DESC;


• Pachet care să conțină toate obiectele definite în cadrul punctului 9 (inclusiv apelarea
lor). Triggeri-i vor fi declanșați de instrucțiuni din subprogramele încapsulate în pachet.
    
CREATE OR REPLACE PACKAGE pkg_busnova
AUTHID CURRENT_USER
AS
    PROCEDURE proc_sistem_loialitate;
    PROCEDURE proc_raport_eficienta_curse(p_luna NUMBER, p_an NUMBER);
    FUNCTION calculeaza_pret_calatorie(p_cursa_id NUMBER, p_statie_plecare_id NUMBER, p_statie_sosire_id NUMBER) RETURN NUMBER;
    PROCEDURE executa_teste_complete;
END pkg_busnova;
/

CREATE OR REPLACE PACKAGE BODY pkg_busnova AS

    PROCEDURE proc_sistem_loialitate AS
        TYPE rec_info_client IS RECORD (
            nume  Client.nume_complet%TYPE,
            email Client.email%TYPE,
            suma_cashback NUMBER
        );
        v_praguri tip_praguri := tip_praguri(5, 10, 15, 20);
        TYPE tip_lista_id IS TABLE OF NUMBER;
        v_ids tip_lista_id;
        TYPE tip_map_detaliat IS TABLE OF rec_info_client INDEX BY PLS_INTEGER;
        v_raport_final tip_map_detaliat;
        v_total_cheltuit NUMBER;
        v_idx PLS_INTEGER;
        v_info_baza Client%ROWTYPE;
    BEGIN
        SELECT DISTINCT client_id BULK COLLECT INTO v_ids FROM Rezervare;
        DBMS_OUTPUT.PUT_LINE('RAPORT LOIALITATE');
        DBMS_OUTPUT.PUT_LINE('-------------------------------------------');
        FOR i IN 1..v_ids.COUNT LOOP
            SELECT * INTO v_info_baza FROM Client WHERE client_id = v_ids(i);
            SELECT SUM(pret) INTO v_total_cheltuit FROM Rezervare WHERE client_id = v_ids(i);
            v_raport_final(v_ids(i)).nume := v_info_baza.nume_complet;
            v_raport_final(v_ids(i)).email := v_info_baza.email;
            IF v_total_cheltuit > 500 THEN
                v_raport_final(v_ids(i)).suma_cashback := v_total_cheltuit * (v_praguri(4)/100);
            ELSIF v_total_cheltuit > 300 THEN
                v_raport_final(v_ids(i)).suma_cashback := v_total_cheltuit * (v_praguri(3)/100);
            ELSIF v_total_cheltuit > 100 THEN
                v_raport_final(v_ids(i)).suma_cashback := v_total_cheltuit * (v_praguri(2)/100);
            ELSE
                v_raport_final(v_ids(i)).suma_cashback := v_total_cheltuit * (v_praguri(1)/100);
            END IF;
        END LOOP;
        v_idx := v_raport_final.FIRST;
        WHILE v_idx IS NOT NULL LOOP
            DBMS_OUTPUT.PUT_LINE('ID: ' || RPAD(v_idx, 3) || ' | ' || RPAD(v_raport_final(v_idx).nume, 18) || ' | ' || RPAD(v_raport_final(v_idx).email, 18) || ' | Cashback: ' || v_raport_final(v_idx).suma_cashback || ' RON');
            v_idx := v_raport_final.NEXT(v_idx);
        END LOOP;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('Eroare: Date clienti negasite.');
        WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('Eroare: ' || SQLERRM);
    END proc_sistem_loialitate;

    PROCEDURE proc_raport_eficienta_curse(p_luna NUMBER, p_an NUMBER) AS
        CURSOR c_detalii_pasageri(p_id_cursa NUMBER) IS
            SELECT c.nume_complet, r.pret, r.nr_loc FROM Client c
            JOIN Rezervare r ON c.client_id = r.client_id
            WHERE r.cursa_id = p_id_cursa ORDER BY r.nr_loc ASC;
        v_total_incasat NUMBER(10, 2);
        v_nr_pasageri NUMBER;
        v_grad_ocupare NUMBER(5, 2);
    BEGIN
        DBMS_OUTPUT.PUT_LINE('RAPORT EFICIENTA CURSE: ' || p_luna || '/' || p_an);
        FOR r_cursa IN (
            SELECT c.cursa_id, c.data_ora_plecare, ru.nume_ruta, a.total_locuri, a.nr_inmatriculare
            FROM Cursa c JOIN Ruta ru ON c.ruta_id = ru.ruta_id JOIN Autobuz a ON c.autobuz_id = a.autobuz_id
            WHERE EXTRACT(MONTH FROM c.data_ora_plecare) = p_luna AND EXTRACT(YEAR FROM c.data_ora_plecare) = p_an
        ) LOOP
            v_total_incasat := 0;
            v_nr_pasageri := 0;
            DBMS_OUTPUT.PUT_LINE('CURSA #' || r_cursa.cursa_id || ' | ' || r_cursa.nume_ruta);
            FOR r_p IN c_detalii_pasageri(r_cursa.cursa_id) LOOP
                v_nr_pasageri := v_nr_pasageri + 1;
                v_total_incasat := v_total_incasat + r_p.pret;
                DBMS_OUTPUT.PUT_LINE('  Loc ' || r_p.nr_loc || ': ' || r_p.nume_complet || ' (' || r_p.pret || ' RON)');
            END LOOP;
            IF v_nr_pasageri > 0 THEN
                v_grad_ocupare := (v_nr_pasageri / r_cursa.total_locuri) * 100;
                DBMS_OUTPUT.PUT_LINE('>> ' || v_nr_pasageri || ' pasageri | Ocupare: ' || v_grad_ocupare || '% | Incasari: ' || v_total_incasat || ' RON');
                IF v_grad_ocupare < 30 THEN DBMS_OUTPUT.PUT_LINE('!! ATENTIE: Cursa neprofitabila (sub 30% ocupare)'); END IF;
            ELSE
                DBMS_OUTPUT.PUT_LINE('   (Cursa nu are rezervari confirmate)');
            END IF;
        END LOOP;
    END proc_raport_eficienta_curse;

    FUNCTION calculeaza_pret_calatorie(p_cursa_id NUMBER, p_statie_plecare_id NUMBER, p_statie_sosire_id NUMBER) RETURN NUMBER AS
        PRAGMA AUTONOMOUS_TRANSACTION;
        ex_cursa_invalida EXCEPTION;
        ex_segment_inexistent EXCEPTION;
        v_pret NUMBER := 0;
        v_statie_plecare VARCHAR2(100);
        v_statie_sosire VARCHAR2(100);
        v_cursa_exista NUMBER := 0;
        v_mesaj_text VARCHAR2(255);
    BEGIN
        SELECT COUNT(*) INTO v_cursa_exista FROM Cursa WHERE cursa_id = p_cursa_id;
        IF v_cursa_exista = 0 THEN RAISE ex_cursa_invalida; END IF;
        BEGIN
            SELECT ps.pret_baza, s1.oras, s2.oras INTO v_pret, v_statie_plecare, v_statie_sosire
            FROM Cursa c
            INNER JOIN Pret_Segment ps ON c.ruta_id = ps.ruta_id
            INNER JOIN Statie s1 ON ps.statie_plecare_id = s1.statie_id
            INNER JOIN Statie s2 ON ps.statie_sosire_id = s2.statie_id
            WHERE c.cursa_id = p_cursa_id AND ps.statie_plecare_id = p_statie_plecare_id AND ps.statie_sosire_id = p_statie_sosire_id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN RAISE ex_segment_inexistent;
        END;
        v_mesaj_text := 'Pret calculat: ' || v_statie_plecare || ' -> ' || v_statie_sosire || ' = ' || v_pret || ' RON';
        INSERT INTO Mesaj (mesaj, tip_mesaj, creat_de) VALUES (v_mesaj_text, 'I', 'FUNC_PRET');
        COMMIT;
        RETURN v_pret;
    EXCEPTION
        WHEN ex_cursa_invalida THEN
            v_mesaj_text := 'EROARE: Cursa #' || p_cursa_id || ' nu exista!';
            INSERT INTO Mesaj (mesaj, tip_mesaj, creat_de) VALUES (v_mesaj_text, 'E', 'FUNC_PRET');
            COMMIT; RETURN -1;
        WHEN ex_segment_inexistent THEN
            v_mesaj_text := 'EROARE: Segment inexistent pentru cursa #' || p_cursa_id;
            INSERT INTO Mesaj (mesaj, tip_mesaj, creat_de) VALUES (v_mesaj_text, 'E', 'FUNC_PRET');
            COMMIT; RETURN -2;
        WHEN OTHERS THEN
            v_mesaj_text := 'EROARE SISTEM: ' || SQLERRM;
            INSERT INTO Mesaj (mesaj, tip_mesaj, creat_de) VALUES (SUBSTR(v_mesaj_text, 1, 255), 'E', 'FUNC_PRET');
            COMMIT; RETURN -99;
    END calculeaza_pret_calatorie;

    PROCEDURE executa_teste_complete AS
        v_rezultat NUMBER;
    BEGIN
        DBMS_OUTPUT.PUT_LINE('=== TESTE PACHET BUSNOVA ===');
        proc_sistem_loialitate;
        proc_raport_eficienta_curse(1, 2026);
        v_rezultat := calculeaza_pret_calatorie(1, 1, 2);
        DBMS_OUTPUT.PUT_LINE('Test pret valid: ' || v_rezultat);
        v_rezultat := calculeaza_pret_calatorie(9999, 1, 2);
        DBMS_OUTPUT.PUT_LINE('Test cursa invalida: ' || v_rezultat);
        v_rezultat := calculeaza_pret_calatorie(1, 1, 999);
        DBMS_OUTPUT.PUT_LINE('Test segment inexistent: ' || v_rezultat);
        INSERT INTO Cursa (ruta_id, autobuz_id, sofer_id, data_ora_plecare, status) VALUES (1, 1, 1, SYSTIMESTAMP + INTERVAL '2' DAY, 'Planificata');
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Trigger verificare mentenanta autobuze executat.');
        BEGIN
            INSERT INTO Rezervare (client_id, cursa_id, nr_loc, statie_plecare_id, statie_sosire_id, pret) VALUES (1, 1, 5, 1, 3, 40);
        EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('Trigger verificare loc ocupat: ' || SQLERRM);
        END;
        EXECUTE IMMEDIATE 'CREATE TABLE TEST_AUDIT (id NUMBER)';
        EXECUTE IMMEDIATE 'ALTER TABLE TEST_AUDIT ADD nume VARCHAR2(50)';
        EXECUTE IMMEDIATE 'DROP TABLE TEST_AUDIT';
        DBMS_OUTPUT.PUT_LINE('Trigger audit schema executat.');
    EXCEPTION
        WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('Eroare: ' || SQLERRM); ROLLBACK;
    END executa_teste_complete;

END pkg_busnova;
/    

--rulare teste complete
EXEC pkg_busnova.executa_teste_complete;
